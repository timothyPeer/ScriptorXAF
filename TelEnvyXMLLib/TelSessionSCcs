using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.IO;
using System.Linq;
using System.Text;
using System.Xml;
using TelEnvyXmlLib.Abstract;
using TelEnvyXmlLib.Directives;
using TelEnvyXmlLib.Enums;
using TelEnvyXmlLib.EventArgs;
using TelEnvyXmlLib.Exceptions;
using TelEnvyXmlLib.Helper;
using TelEnvyXmlLib.Logging;

namespace TelEnvyXmlLib
{
    /* 
     * Log output should be directed from the NLog.Conf file. 
     * 
     *
     */
    public partial class TelSessionSC : TerminalScreen
    {
        private string _fileToProcess;
        private readonly object _syncRoot = new object();
        private bool ReleasedForProcessing = true;


        public void Disconnect()
        {
            nsoftware.IPWorks.Ipport sPortL = getIPInstance();
            sPortL.Disconnect();
        }


        public TelSessionSC()
        {
            InitializeComponent();
            transactionGUID = Guid.NewGuid();
            TransactionTimestamp = DateTime.Now;
            //Logger.Initialize(@"c:\envy\test.txt");
            ReleaseForProcessing += TelSessionV3_ReleaseForProcessing1;
        }

        private void TelSessionV3_ReleaseForProcessing1(object sender, ReleaseForProcessingEventArgs e)
        {
            ReleasedForProcessing = e.ReadyToSend;
        }


    


        public TelSessionV3(IContainer container)
        {
            container.Add(this);

            InitializeComponent();
            transactionGUID = Guid.NewGuid();
            TransactionTimestamp = DateTime.Now;
        }
 
        #region Events

        public event EventHandler<TelLogWriterEventArg> ChangeLogFileName;
        /// <summary>
        /// Handles the <see cref="E:WriteLog" /> event.
        /// </summary>
        /// <param name="sender">The sender.</param>
        /// <param name="e">The <see cref="EventArgs"/> instance containing the event data.</param>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for OnWriteLog
        protected virtual void OnChangeLogFileName(object sender, TelLogWriterEventArg e)
        {
            EventHandler<TelLogWriterEventArg> handler = ChangeLogFileName;
            if (handler != null)
                handler(sender, e);
        }
        /// <summary>
        /// Occurs when [log written].
        /// </summary>
        public event EventHandler<TelLogWriterEventArg> LogWriting;
        /// <summary>
        /// Occurs before TelEnvyXmlLib XML node is processed by the TexSession.
        /// </summary>
		public event EventHandler<TeLSessionNodeProcessEventArg> NodeProcessing;
        /// <summary>
        /// Occurs after a TelEnvyXmlLib XML node is processed by the TexSession.
        /// </summary>
		public event EventHandler<TeLSessionNodeProcessEventArg> NodeProcessed;
        /// <summary>
        /// The Event-handler passes captured data from the TelEnvyXmlLib session to the application.
        /// </summary>
		public event EventHandler<GrabChangedEventArgs> GrabChanged;

        /// <summary>
        /// Occurs when the node canceled.
        /// </summary>
        public event EventHandler<TeLSessionNodeCancelEventArg> NodeCanceled;
        /// <summary>
        /// Called when [log written].
        /// </summary>
        /// <param name="sender">The sender.</param>
        /// <param name="e">The e.</param>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for OnLogWritten
        protected virtual void OnLogWritten(object sender, TelLogWriterEventArg e)
        {
            EventHandler<TelLogWriterEventArg> handler = LogWriting;
            if (handler != null)
                handler(sender, e);
        }
        /// <summary>
        /// Called when [node canceled].
        /// </summary>
        /// <param name="sender">The sender.</param>
        /// <param name="e">Message Argument.</param>
        protected virtual void OnNodeCanceled(object sender, TeLSessionNodeCancelEventArg e)
        {
            EventHandler<TeLSessionNodeCancelEventArg> handler = NodeCanceled;
            if (handler != null)
                handler(sender, e);
        }
        /// <summary>
        /// Called when the TelEnvyXmlLib XML directive is processing.
        /// </summary>
        /// <param name="e">The TelEnvyXmlLib XML Directive.</param>
		protected void OnNodeProcessing(TeLSessionNodeProcessEventArg e)
        {
            if (NodeProcessing != null)
            {
                NodeProcessing(this, e);
            }
        }
        /// <summary>
        /// Called when the TelEnvyXmlLib XML directive is processed.
        /// </summary>
        /// <param name="e">The TelEnvyXmlLib XML Directive.</param>
		protected void OnNodeProcessed(TeLSessionNodeProcessEventArg e)
        {
            if (NodeProcessed != null)
            {
                NodeProcessed(this, e);
            }
        }
        /// <summary>
        /// Handles the <see cref="TeLSession.GrabChanged" /> event. GrabChanged passes data from the TelEnvyXmlLib session back to the application for processing.
        /// </summary>
        /// <param name="e">The <see cref="GrabChangedEventArgs" /> instance containing the event data.</param>
		protected void OnGrabChanged(GrabChangedEventArgs e)
        {
            if (GrabChanged != null)
            {
                GrabChanged(this, e);
            }
        }



        #endregion

        #region Public methods

        /// <summary>
        /// The timer lock
        /// </summary>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for timerLock
        object timerLock = new object();
        /// <summary>
        /// This method sets the logging level to LogLevel::Verbose.
        /// </summary>
		public void SetLoggingTrace()
        {
            //TelEnvyLogLevel = NLog.LogLevel.Trace;
        }
        /// <summary>
        /// This method sets the Logging level to LogLevel::Debug.
        /// </summary>
		public void SetLoggingDebug()
        {
            //TelEnvyLogLevel = NLog.LogLevel.Debug;
        }
        /// <summary>
        /// This method sets the Logging level to LogLevel::Info.
        /// </summary>

        public void SetLoggingInfo()
        {//
         //   TelEnvyLogLevel = NLog.LogLevel.Info;
        }
        /// <summary>
        /// This method sets the Logging level to LogLevel::Error.
        /// </summary>

        public void SetLoggingError()
        {
            //TelEnvyLogLevel = NLog.LogLevel.Error;
        }
        /// <summary>
        /// Turns off logging.
        /// </summary>

        public void SetLoggingOff()
        {
           // TelEnvyLogLevel = NLog.LogLevel.Off;
        }

        /// <summary>
        /// Sets the logging suffix unique identifier.
        /// </summary>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for SetLoggingSuffixGUID
        public void SetLoggingSuffixGUID()
        {
            LogOpt = EnumLoggingOptions.GUID;
        }
        /// <summary>
        /// The b logging suffix is timestamp
        /// </summary>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for bLoggingSuffixIsTimestamp

    //    private int pngCounter;
     //   private bool _debugEnabled;
       

        /// <summary>
        /// The loginInfo file provides for a standard interface for passing basic configuration from the application to the component.
        /// </summary>
        /// <param name="_settings">The settings.</param>
        public void ConfigureSettings(LoginInfo _settings)
        {
            settings = _settings;

            int screenRows = _settings.TeLScreenLength > 0 ? _settings.TeLScreenLength : 24;
            int screenColumns = _settings.TeLScreenWidth > 0 ? _settings.TeLScreenWidth : 132;
            //int timeOut = _settings.TeLServerTimeout > 0 ? _settings.TeLServerTimeout : DefaultServerTimeout;
            //if (_helper != null)
            //{
            //    this._helper.Terminal.SetScreenSize(screenColumns, screenRows);
            //    this._helper.sendDataWaitForDataTimeout = _settings.TeLServerTimeout;
            //    this._helper.receiveDataWaitForDataTimeout = _settings.TeLServerTimeout;
            //}
            settings.TeLHostPort = _settings.TeLHostPort;
            settings.TeLHostname = _settings.TeLHostname;
            setScreenGeometry(screenRows, screenColumns);


        }

        /// <summary>
        /// Sets the debugging screen to the control.
        /// Interactive debugging must be enabled otherwise does nothing.
        /// </summary>
        /// <param name="debugScreen">Debugging screen.</param>
		//public void SetDebugScreen(Rebex.TerminalEmulation.TerminalControl debugScreen)
  //      {
  //          _debugScreen = debugScreen;
  //          _debugEnabled = true;
  //      }

        /// <summary>
        /// Sets the send data wait for data timeout.
        /// </summary>
        /// <param name="timeout">The timeout.</param>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for SetSendDataWaitForDataTimeout
        //public void SetSendDataWaitForDataTimeout(int timeout = 10)
        //{
        //    this.sendDataWaitForDataTimeout = timeout;
        //}


        /// <summary>
        /// Processes specified XML file.
        /// </summary>
        /// <param name="fileToProcess">The file to be processed.</param>
        /// <exception cref="ArgumentException">File cannot be empty. - fileToProcess</exception>
        public void ProcessFile(string fileToProcess)
        {
            logIncrementing = 0;
            recordIncrementing = 0;
            debugIncrementing = 0;
           
            transactionGUID = Guid.NewGuid();
            TransactionTimestamp = DateTime.Now;

            if (string.IsNullOrEmpty(fileToProcess))
            {
               // logger.Error(ex, "FileToProcess-File cannot be empty."); // render the exception with ${exception}
               // throw ;
            }

            lock (_syncRoot)
            {
                _fileToProcess = fileToProcess;

                XmlDocument xmlDoc = new XmlDocument();
                xmlDoc.Load(fileToProcess);
                Process(xmlDoc);
                //string txt = GetXMLProcessedPath();

            }
        }

        /// <summary>
        /// Processes specified XML data.
        /// </summary>
        /// <param name="xmlData">XML data to be processed.</param>
        /// <param name="fileName">File name used for Logging, Debugging and Recordering purpose.</param>
        /// <exception cref="ArgumentException">XmlData cannot be empty. - xmlData
        /// or
        /// FileName cannot be empty. - fileName</exception>
		public void ProcessXml(string xmlData, string fileName)
        {

            if (string.IsNullOrEmpty(xmlData))
            {
                //logger.Error(new ArgumentException("xmlData-XmlData cannot be empty.")); // render the exception with ${exception}
                //throw;
            }
            if (string.IsNullOrEmpty(fileName))
                throw new ArgumentException("FileName cannot be empty.", "fileName");

            lock (_syncRoot)
            {
                _fileToProcess = fileName;

                XmlDocument xmlDoc = new XmlDocument();
                xmlDoc.LoadXml(xmlData);
                Process(xmlDoc);
            }
        }

        #endregion
        #region fields
        public LoginInfo settings;       // Settings passed from the main application
        private bool _canceling;
        Session _session;               // A root element to be processed
        /// <summary>
        /// The log enabled
        /// </summary>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for _logEnabled
		bool _logEnabled;
        //private readonly bool LoggingEnabled;
        //private readonly bool DebuggingEnabled;
        //    private readonly int? ServerPort = 23;
        //     private StringBuilder _receivedData = null;
        ///*     private int countOfSocketBytes=0;*/
        //     private string _matchedData;
        //   private string _moduleName;

        public string LogFileName { get; private set; }


        #endregion
        #region Main methods

        /// <summary>
        /// Cancels the running TelEnvyXmlLib Session.
        /// </summary>
        public void Cancel()
        {
            _canceling = true;
        }


        /// <summary>
        /// Processes the specified XML document.
        /// </summary>
        /// <param name="xmlDoc">The XML document.</param>
        /// <exception cref="TeLXMLInvalidTagException"></exception>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for Process

        public void Process(XmlDocument xmlDoc)
        {
            // Initialize counters;
            transactionGUID = Guid.NewGuid();
            TransactionTimestamp = DateTime.Now;
            logIncrementing = 0;
            recordIncrementing = 0;
            debugIncrementing = 0;
           

            try
            {
                // parse the whole XML first
                _session = TeLSessionXmlParser.Parse(xmlDoc.DocumentElement) as Session;
              // TelEnvyXmlLib.Logging.Log.instance.Trace("Process.XmlDocument-{0}\r", xmlDoc.ToString());
            }
            catch (Exception ex)
            {
              // TelEnvyXmlLib.StaticLogger.LogError(this.GetType(),"Error-Process.XmlDocument-{0}\r{1}", xmlDoc.ToString(),ex.Message);
                throw new TeLXMLInvalidTagException(xmlDoc.ToString(), ex);
            }
            finally
            {

            }

            if (_session == null)
            {
                  throw new TeLXMLInvalidTagException(string.Format("TeLXMLInvalidTag:\n An invalid tag found.\nExpected <Session> as a document root node and found {0}", xmlDoc.DocumentType.Name));
            }

            try
            {
                // process parsed nodes
                OnReleaseForProcessing(new ReleaseForProcessingEventArgs(true));
                Process(_session, 0);
                IsFaulted = false;
            }
            catch (Exception ex)
            {
                IsFaulted = true;
                StaticLogger.LogError(ModuleString, ex, string.Format("Process: XMLDocument\n"));

                // Exception = ex;
            }
            finally
            {
                base.Disconnect();
                logIncrementing++;
                debugIncrementing++;
            }
        }



        //private void Process(XmlDocument xmlDoc)
        //{
        //	// parse the whole XML first
        //	_session = ComSessionXmlParser.Parse(xmlDoc.DocumentElement) as ComSessionSessionNode;
        //	if (_session == null)
        //              throw new TeLXMLInvalidTag(string.Format("TeLXMLInvalidTag:\n An invalid tag found.\nExpected <Session> as a document root node and found {0}",xmlDoc.DocumentType.Name));

        //	try
        //	{
        //		// process parsed nodes
        //		Process(_session, 0);				
        //	}
        //	finally
        //	{
        //		if (_logger != null)
        //			_logger.Close();

        //		if (_helper != null)
        //		{
        //			if (_helper.Terminal.Recorder != null)
        //			{
        //				_helper.Terminal.Recorder.Close();
        //				_helper.Terminal.Recorder = null;
        //			}

        //			_helper.Terminal.Dispose();
        //		}
        //	}
        //}
        /// <summary>
        /// Processes the specified c node.
        /// </summary>
        /// <param name="cNode">The c node.</param>
        /// <param name="level">The level.</param>
        /// <exception cref="TeLInvalidCastException">
        /// </exception>
        /// <exception cref="TeLXMLInvalidTagException"></exception>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for Process

        private void Process(TeLSessionNode cNode, int level)
        {
            if (cNode.Data == null)
            {
                StaticLogger.LogTrace(ModuleString,  string.Format("Process {0}{1}", "".PadLeft(level), cNode.TeLTag));
            }
            else
            {
                StaticLogger.LogTrace(ModuleString, string.Format("Process {0}{1} [{2}]", "".PadLeft(level), cNode.TeLTag, cNode.Data));
            }
            string startTime = DateTime.Now.ToString();
            TimeSpan duration;
            int doEventCnt = 0;
            nsoftware.IPWorks.Ipport sPortL = getIPInstance();
            do
            {
                string endTime = DateTime.Now.ToString();
                if ((doEventCnt % 20) == 0)
                {
                    if ((!sPortL.Connected) && (!ReleasedForProcessing))
                    {
                        StaticLogger.LogError(ModuleString,new TeLMessageException("Process:DoEventCnt"), "Process:cNode:Level socket is disconnect, and not released for processing.");
                        throw new TeLMessageException("The socket to the host was closed during a critical operation.");
                    }
                    try
                    {
                        if (sPortL.Connected == true)
                        {
                            sPortL.DoEvents();
                            StaticLogger.LogTrace(ModuleString, "DoEvents Called");
                        }
                    }
                    catch(Exception e)
                    {
                        StaticLogger.LogError(ModuleString, e, "Process:cNode:Level");
                       // Console.WriteLine("test");
                    }
                }
                duration = DateTime.Parse(endTime).Subtract(DateTime.Parse(startTime));
               
                  //  if (duration.Seconds >= 6) throw new TeLMessageException(string.Format("Exceeded Reasonable Timeout 6 secs to wait for a response from the socket. Socket Connected: {0} - SocketHost-Port: {1}-{2}.", getIPInstance().Connected.ToString(), getIPInstance().RemoteHost, getIPInstance().RemotePort));

                doEventCnt++;
            } while (!ReleasedForProcessing );
            ReleasedForProcessing = false;      // wait for processing any data from the next command sequence
            TimeSpan span = DateTime.Parse(DateTime.Now.ToString()).Subtract(DateTime.Parse(startTime));
           

            if (_canceling)
                return;

            //string pad = new string(' ', level * 2);
            //Console.WriteLine(pad + cNode.Tag);
            OnNodeProcessing(new TeLSessionNodeProcessEventArg(cNode, level));
            switch (cNode.TeLTag)
            {
                
                case XmlTag.Session:
                    {
                        Session ssNodeS = cNode as Session;
                        if (ssNodeS != null)
                        {
                            if (ssNodeS.SocketType.ToUpper() == "STREAM")
                            {
                                nsoftware.IPWorks.Ipport sPort = getIPInstance();
                                if (!string.IsNullOrEmpty(ssNodeS.EOL))
                                    sPort.EOL = ssNodeS.EOL;
                              //  sPort.Config(string.Format("UseBackGroundThread={0}", ssNodeS.UseBackgroundThread));
                                sPort.Config(string.Format("ConnectionTimeOut={0}", ssNodeS.ConnectionTimeout));
                                sPort.Config(string.Format("Linger={0}", ssNodeS.SocketLinger));
                                sPort.Config(string.Format("TCPKeepAlive={0}", ssNodeS.TCPKeepAlive));
                                /*
                                 * Rule: MaxLineLength
                                 * If an EOL string is found in the input stream before MaxLineLength bytes are received, the DataIn event is fired with the EOL parameter set to True, and the buffer is reset.
                                 * If no EOL is found, and MaxLineLength bytes are accumulated in the buffer, the DataIn event is fired with the EOL parameter set to False, and the buffer is reset.
                                 * The minimum value for MaxLineLength is 256 bytes. The default value is 2048 bytes. The maximum value is 65536 bytes.
                                 */
                                if ((ssNodeS.MaxLineLength == -1))
                                    sPort.Config(string.Format("MaxLineLength={0}", 65536)); 
                                else
                                    sPort.Config(string.Format("MaxLineLength={0}", ssNodeS.MaxLineLength));
                                sPort.Config(string.Format("OutBufferSize={0}", ssNodeS.OutBufferSize));
                                sPort.Config(string.Format("InBufferSize={0}", ssNodeS.InBufferSize));
                                /*
                                 * Rule: TcpNoDelay
                                 *When true, the socket will send all data that is ready to send at once. When false, the socket will send smaller buffered packets of data at small intervals. This is known as the Nagle algorithm.
                                 * By default, this config is set to false. 
                                 */
                                sPort.Config(string.Format("TcpNoDelay={0}", ssNodeS.TcpNoDelay));
                                StaticLogger.LogTrace(ModuleString, string.Format("EOL\t\t:{0}\nConnectionTimeOut: {1}\nSocketLinger: {2}\nTCPKeepAlive: {3}\nMaxLineLength: {4}\nOutBufferSize:{5}\nInBufferSize:{6}\nTcpNoDelay:{7}",
                                    ssNodeS.EOL, ssNodeS.ConnectionTimeout, ssNodeS.SocketLinger, ssNodeS.TCPKeepAlive, ssNodeS.MaxLineLength, ssNodeS.OutBufferSize, ssNodeS.InBufferSize,ssNodeS.TcpNoDelay));
                            }
                            if (ssNodeS.SocketType.ToUpper() == "FORM")
                            {
                            //    nsoftware.IPWorks.Telnet sPort = getTNInstance();
                            //    //if (!string.IsNullOrEmpty(ssNodeS.EOL))
                            //    //    sPort.EOL = ssNodeS.EOL;
                            //    ////  sPort.Config(string.Format("UseBackGroundThread={0}", ssNodeS.UseBackgroundThread));
                            //    sPort.Config(string.Format("ConnectionTimeOut={0}", ssNodeS.ConnectionTimeout));
                            //    sPort.Config(string.Format("Linger={0}", ssNodeS.SocketLinger));
                            //    sPort.Config(string.Format("TCPKeepAlive={0}", ssNodeS.TCPKeepAlive));
                            //    /*
                            //     * Rule: MaxLineLength
                            //     * If an EOL string is found in the input stream before MaxLineLength bytes are received, the DataIn event is fired with the EOL parameter set to True, and the buffer is reset.
                            //     * If no EOL is found, and MaxLineLength bytes are accumulated in the buffer, the DataIn event is fired with the EOL parameter set to False, and the buffer is reset.
                            //     * The minimum value for MaxLineLength is 256 bytes. The default value is 2048 bytes. The maximum value is 65536 bytes.
                            //     */
                            //    if (!(ssNodeS.MaxLineLength == -1))
                            //        sPort.Config(string.Format("MaxLineLength={0}", ssNodeS.MaxLineLength));

                            //    sPort.Config(string.Format("OutBufferSize={0}", ssNodeS.OutBufferSize));
                            //    sPort.Config(string.Format("InBufferSize={0}", ssNodeS.InBufferSize));
                            //    /*
                            //     * Rule: TcpNoDelay
                            //     *When true, the socket will send all data that is ready to send at once. When false, the socket will send smaller buffered packets of data at small intervals. This is known as the Nagle algorithm.
                            //     * By default, this config is set to false. 
                            //     */

                            //    StaticLogger.LogTrace(ModuleString, string.Format("EOL\t\t:{0}\nConnectionTimeOut: {1}\nSocketLinger: {2}\nTCPKeepAlive: {3}\nMaxLineLength: {4}\nOutBufferSize:{5}\nInBufferSize:{6}\nTcpNoDelay:{7}",
                            //        ssNodeS.EOL, ssNodeS.ConnectionTimeout, ssNodeS.SocketLinger, ssNodeS.TCPKeepAlive, ssNodeS.MaxLineLength, ssNodeS.OutBufferSize, ssNodeS.InBufferSize, ssNodeS.TcpNoDelay));
                            }
                        }
                        OnReleaseForProcessing(new ReleaseForProcessingEventArgs(true));
                        TeLSessionGroupNode lNode = cNode as TeLSessionGroupNode;
                        foreach (TeLSessionNode node in lNode.Nodes)
                        {
                            Process(node, level + 1);
                        }
                    }
                    break;
                case XmlTag.SessSeq:
                case XmlTag.GroupCollection:
                    SessSeq ssNode = cNode as SessSeq;
                    if (ssNode != null)
                    {
                        nsoftware.IPWorks.Ipport sPort = this.getIPInstance();// Instance();
                        setServerName(ssNode.ServerName);
                        setServerPort(ssNode.ServerPort.Value);
                        StaticLogger.LogTrace(ModuleString, string.Format("ServerName:{0}\nServerPort:{1}", sPort.RemoteHost, sPort.RemotePort));
                        terminalMode = ssNode.Mode; // we need to set the terminal mode as terminal mode determines the geometry of the buffer and, how a connection is made to the host.

                        if (terminalMode == TerminalMode.Form) setScreenGeometry(ssNode.PageLength.Value, ssNode.PageWidth.Value);
                        if (terminalMode == TerminalMode.Stream)
                        {
                            TerminationString = ssNode.TerminationString.ToUpper();
                            setConnectionToSocket(); // credentials are not needed since we are communicating with a TCP Port Directly
                        }
                    }
                    OnReleaseForProcessing(new ReleaseForProcessingEventArgs(true));
                    TeLSessionGroupNode gNode = cNode as TeLSessionGroupNode;
                    foreach (TeLSessionNode node in gNode.Nodes)
                    {
                        Process(node, level + 1);
                    }
                    break;

                case XmlTag.If:
                    If ifNode = cNode as If;
                    List<TeLSessionNode> ifNodesToProcess = ResolveCondition(ifNode.Condition) ? ifNode.ConditionNodes : ifNode.ElseNodes;
                    if (ifNodesToProcess != null)
                    {
                        foreach (TeLSessionNode node in ifNodesToProcess)
                        {
                            Process(node, level + 1);
                        }
                    }
                    break;

                case XmlTag.While:
                    While whileNode = cNode as While;
                    while (ResolveCondition(whileNode.Condition))
                    {
                        foreach (TeLSessionNode node in whileNode.ConditionNodes)
                        {
                            Process(node, level + 1);
                        }
                    }
                    break;

                case XmlTag.SendData:
                    SendData(cNode.Data);
                    break;
                case XmlTag.SendEnter:
                    SendData(string.Format("{0}\n", cNode.Data));
                    break;
                case XmlTag.SendTab:
                    SendData(string.Format("{0}\t", cNode.Data));
                    break;

                case XmlTag.SendSpace:
                    SendData(string.Format("{0} ", cNode.Data));
                    break;
                case XmlTag.SendPF1:
                case XmlTag.SendPF2:
                case XmlTag.SendPF3:
                case XmlTag.SendPF4:
                    SendPF(1 + cNode.TeLTag - XmlTag.SendPF1, cNode.Data);
                    break;

                case XmlTag.SendF1:
                case XmlTag.SendF2:
                case XmlTag.SendF3:
                case XmlTag.SendF4:
                case XmlTag.SendF5:
                case XmlTag.SendF6:
                case XmlTag.SendF7:
                case XmlTag.SendF8:
                case XmlTag.SendF9:
                case XmlTag.SendF10:
                case XmlTag.SendF11:
                case XmlTag.SendF12:
                    SendF(1 + cNode.TeLTag - XmlTag.SendF1);
                    break;
                case XmlTag.SendLogin:
                    {
                        if (terminalMode == TerminalMode.Form)
                        {
                            LoginPair gLogin = cNode as LoginPair;
                            ConnectAndLogin(gLogin);

                            SendEnter(gLogin.userName);
                            if (!string.IsNullOrEmpty(gLogin.password))
                            {
                                SendData(gLogin.password);
                            }
                        }
                        else
                        {
                            throw new TeLXMLInvalidTagException("The mode is configured as stream while attempting to send a SendLogin tag - which is not allowed.");
                        }
                        
                    }
                    break;
                case XmlTag.Expect:
                    Expect eNode = cNode as Expect;
                    string result = Expect(cNode.Data);
                    if (eNode.Grab)
                    {
                        string[] lines = result.Split('\n');
                        //lines = lines.Select(line => line.Trim('\r')).ToArray<string>();
                        //byte[] byteArray = lines[0].ToArray<byte>();
                        OnGrabChanged(new GrabChangedEventArgs(cNode.Name, lines));
                        //nsoftware.IPWorks.Telnet sPort = getTNInstance();
                      
                    }
                    break;
                case XmlTag.WaitForDataWholeScreen:
                    WaitForData wfdwsNode = cNode as WaitForData;
                    WaitForDataWholeScreen(cNode.Data, wfdwsNode.Timeout);
                    break;
                case XmlTag.WaitForDataOneRow:
                    WaitForData wfdorNode = cNode as WaitForData;
                    WaitForDataOneRow(cNode.Data, wfdorNode.Row.Value, wfdorNode.Timeout);
                    break;
                case XmlTag.WaitForDataRegion:
                    WaitForData wfdrNode = cNode as WaitForData;
                    WaitForDataRegion(cNode.Data, wfdrNode.Column.Value, wfdrNode.Row.Value, wfdrNode.Width.Value, wfdrNode.Height.Value, wfdrNode.Timeout);
                    break;
                case XmlTag.WaitForCursor:
                    WaitForCursor wfcNode = cNode as WaitForCursor;
                    WaitForCursor(wfcNode.Column, wfcNode.Row);
                    break;

                case XmlTag.GrabLine:
                    {
                        GrabLine glNode = cNode as GrabLine;
                        string line = GrabLine(glNode.Column, glNode.Row, glNode.Width);
                        OnGrabChanged(new GrabChangedEventArgs(cNode.Name, new string[] { line }));
                    }
                    break;
                case XmlTag.GrabLines:
                    {
                        GrabLines glsNode = cNode as GrabLines;
                        string[] lines = GrabLines(glsNode.Column, glsNode.Row, glsNode.Width, glsNode.Height);
                        OnGrabChanged(new GrabChangedEventArgs(cNode.Name, lines));

                    }
                    break;
                case XmlTag.GrabInt32:
                    {
                        GrabLine glNode = cNode as GrabLine;
                        string line = GrabLine(glNode.Column, glNode.Row, glNode.Width);
                        try
                        {
                            Int32 txx = Convert.ToInt32(line);
                        }
                        catch (Exception ex)
                        {
                            throw new TeLInvalidCastException(string.Format("TeXInvalidCast:\nInvalid System.Int32 Cast Attempt for [{0}].\nMessage:{1}.", line, ex.Message)); ;
                        }

                        OnGrabChanged(new GrabChangedEventArgs(cNode.Name, new string[] { line }));
                    }
                    break;
                case XmlTag.GrabDouble:
                    {
                        GrabLine glNode = cNode as GrabLine;
                        string line = GrabLine(glNode.Column, glNode.Row, glNode.Width);
                        try
                        {
                            double txx = Convert.ToDouble(line);
                        }
                        catch (Exception ex)
                        {
                            throw new TeLInvalidCastException(string.Format("TeLInvalidCast:\nInvalid System.Double Cast Attempt for [{0}].\nMessage:{1}.", line, ex.Message));
                        }
                        OnGrabChanged(new GrabChangedEventArgs(cNode.Name, new string[] { line }));
                    }
                    break;
                default:
                    {
                        throw new TeLXMLInvalidTagException(string.Format("TeLXMLInvalidTag:\n XmlTag <{0}> out of range.", cNode.TeLTag));
                    }
            }
            OnNodeProcessed(new TeLSessionNodeProcessEventArg(cNode, level));
        }





        /// <summary>
        /// Connects the specified node.
        /// </summary>
        /// <param name="node">The node.</param>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for Connect

        protected internal void Connect(SessSeq node)
        {
            _debugEnabled = node.DebuggingEnabled ;
            _logEnabled = node.LoggingEnabled ;
            if (_logEnabled)
            {
                TelEnvyXmlLib.StaticLogger.LogTrace(GetType(),string.Format("TelSessionV3 Connect:-{0}", node.ToString()));
            }
            TelEnvyXmlLib.StaticLogger.LogTrace(GetType(), string.Format("HostName Server Host: {0}",  node.ServerName));
            nsoftware.IPWorks.Ipport ip = getIPInstance();
            if (ip.Connected == false)
            {
                ip.LocalHost = "localhost";
                ip.LocalPort = 23;
                ip.RemoteHost = node.ServerName;
                ip.RemotePort = node.ServerPort.Value;
                OnReleaseForProcessing(new ReleaseForProcessingEventArgs(true));
            }
        }

        /// <summary>
        /// Handles the RemoteResize event of the terminal control.
        /// </summary>
        /// <param name="sender">The source of the event.</param>
        /// <param name="e">The <see cref="RemoteResizeEventArgs" /> instance containing the event data.</param>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for terminal_RemoteResize
        //void terminal_RemoteResize(object sender, RemoteResizeEventArgs e)
        //      {
        //          //_helper.Terminal.SetScreenSize(e.Columns, e.Rows);
        //          TelEnvyXmlLib.StaticLogger.LogTrace(6100, "Virtual Terminal: ", string.Format("ScreenSize Columns: {0} Rows: {1}", e.Columns, e.Rows));
        //      }




        /// <summary>
        /// Resolves the condition.
        /// </summary>
        /// <param name="condition">The condition.</param>
        /// <returns><c>true</c> if XXXX, <c>false</c> otherwise.</returns>
        /// <exception cref="NotImplementedException"></exception>
        /// <exception cref="TeLConditionOutOfRangeException"></exception>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for ResolveCondition
        private bool ResolveCondition(Conditions.ConditionBase condition)
        {
            Conditions.LogicalCondition lcondition = condition as Conditions.LogicalCondition;
            Conditions.FinalCondition fcondition = condition as Conditions.FinalCondition;
            switch (condition.ConditionType)
            {
                case IfConditionType.Not:
                    return !ResolveCondition(lcondition.ChildConditions[0]);

                case IfConditionType.And:
                    foreach (Conditions.ConditionBase child in lcondition.ChildConditions)
                    {
                        if (!ResolveCondition(child))
                            return false;
                    }
                    return true;

                case IfConditionType.Or:
                    foreach (Conditions.ConditionBase child in lcondition.ChildConditions)
                    {
                        if (ResolveCondition(child))
                            return true;
                    }
                    return false;

                case IfConditionType.EmptyIfCondition:
                    return fcondition.ConditionNodes.Count > 0;

                case IfConditionType.DataWithinRegion:
                    Conditions.DataWithinRegionCondition dwrCondition = condition as TelEnvyXmlLib.Conditions.DataWithinRegionCondition;
                    return IsDataWithinRegion(dwrCondition.Pattern, dwrCondition.Column, dwrCondition.Row, dwrCondition.Width, dwrCondition.Height);

                case IfConditionType.DataBeforeCursorPosition:
                    DataBeforeCursorPosition dbfCondition = condition as DataBeforeCursorPosition;
                    //to do 
                    //return IsDataWithinRegion(dbfCondition.Pattern, 0, _helper.Terminal.Screen.CursorTop, _helper.Terminal.Screen.CursorLeft, 1);
                    return false;

                case IfConditionType.CursorAtPosition:
                case IfConditionType.CursorWithinRegion:
                case IfConditionType.DataAtCursorPosition:
                    throw new NotImplementedException();

                default:
                    throw new TeLConditionOutOfRangeException(string.Format("ConditionType [{0}] out of range.", condition.ConditionType));
            }
        }

        /// <summary>
        /// Determines whether [is data within region] [the specified pattern].
        /// </summary>
        /// <param name="pattern">The pattern.</param>
        /// <param name="column">The column.</param>
        /// <param name="row">The row.</param>
        /// <param name="width">The width.</param>
        /// <param name="height">The height.</param>
        /// <returns><c>true</c> if [is data within region] [the specified pattern]; otherwise, <c>false</c>.</returns>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for IsDataWithinRegion
		private bool IsDataWithinRegion(string pattern, int column, int row, int width, int height)
        {
            bool result = TestRegion(pattern, column, row, width, height);
            Save();
            return result;
        }

        private bool TestRegion(string pattern, int row,int column, int width, int height)
        {
            throw new NotImplementedException();
        }

        #endregion

        #region Grab data
        /// <summary>
        /// This routine process returns multiple lines back to the component.
        /// Strings are not formatted.
        /// Considerations:
        /// This method returns to the application an array of strings given the geometry offset from:
        /// The offset in the stream begins on this ROW to HEIGHT (number of rows) in the telnet stream. For each row,
        /// starting at COLUMN, a string is the size of WIDTH of n bytes.
        /// </summary>
        /// <param name="column">The column.</param>
        /// <param name="row">The row.</param>
        /// <param name="width">The width.</param>
        /// <param name="height">The height.</param>
        /// <returns>System.String[].</returns>
        /// <exception cref="TeLOutputBufferOverFlowException"></exception>

        private string[] GrabLines(int row, int column, int width, int height)
        {
            int buffersize = Columns;
            if ((column + width) > buffersize) throw new TeLOutputBufferOverFlowException(string.Format("GrabLines: \n TeXOutputBufferOverFlow Exception\nScreenSize is [{0}], attemped scrap start offset at [{1}] of [{2}] length.", buffersize, column, width));

            return GetRegionText(row,column, width, height);
        }
        /// <summary>
        /// This routine process returns one line back to the component.
        /// Strings are not formatted.
        /// Considerations:
        /// This method returns to the application an array of strings given the geometry offset from:
        /// The offset in the stream begins on this ROW to HEIGHT (number of rows) in the telnet stream. For each row,
        /// starting at COLUMN, a string is the size of WIDTH of n bytes.
        /// </summary>
        /// <param name="column">The column.</param>
        /// <param name="row">The row.</param>
        /// <param name="width">The width.</param>
        /// <returns>System.String.</returns>
        /// <exception cref="TeLOutputBufferOverFlowException"></exception>

        private string GrabLine(int row, int column, int width)
        {
            int buffersize = Columns;
            if ((column + width) > buffersize) throw new TeLOutputBufferOverFlowException(string.Format("GrabLine: \n TeXOutputBufferOverFlow Exception\nScreenSize is [{0}], attemped scrap start offset at [{1}] of [{2}] length.", buffersize, column, width));

            return GetRegionText( row,column, width, 1)[0];
        }
        /// <summary>
        /// Grabs the int32.
        /// </summary>
        /// <param name="column">The column.</param>
        /// <param name="row">The row.</param>
        /// <param name="width">The width.</param>
        /// <returns>System.Nullable&lt;System.Int32&gt;.</returns>
        /// <exception cref="TeLOutputBufferOverFlowException"></exception>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for GrabInt32

        private int? GrabInt32(int row, int column,int width)
        {

            int buffersize = Columns;
            if ((column + width) > buffersize) throw new TeLOutputBufferOverFlowException(string.Format("GrabInt32: \n TeXOutputBufferOverFlow Exception\nScreenSize is [{0}], attemped scrap start offset at [{1}] of [{2}] length.", buffersize, column, width));
            string text = GetRegionText( row,column, width, 1)[0];
            int result;

            if (int.TryParse(text.Trim(), out result))
                return result;
            else
                return null;
        }
        /// <summary>
        /// Grabs the double.
        /// </summary>
        /// <param name="column">The column.</param>
        /// <param name="row">The row.</param>
        /// <param name="width">The width.</param>
        /// <returns>System.Nullable&lt;System.Double&gt;.</returns>
        /// <exception cref="TeLOutputBufferOverFlowException"></exception>
        /// <autogeneratedoc />
        /// TODO Edit XML Comment Template for GrabDouble
		private double? GrabDouble(int column, int row, int width)
        {
            int buffersize = Columns;
            if ((column + width) > buffersize) throw new TeLOutputBufferOverFlowException(string.Format("GrabDouble: \n TeXOutputBufferOverFlow Exception\nScreenSize is [{0}], attempted scrap start offset at [{1}] of [{2}] length.", buffersize, column, width));

            string text = GetRegionText(row, column,width, 1)[0];
            double result;

            if (double.TryParse(text.Trim(), out result))
                return result;
            else
                return null;
        }

        #endregion

    

        #region Helper methods

    
    
    
        #endregion
    }
}
